### Decoratorパターン

クラスの組み合わせを変えることで機能の追加ができる。<br>

1. 利用シーン・メリット<br>

  インターフェースを変えずに機能を追加したい場合は通常、機能を追加する場合には継承を利用する。<br>
  継承したメソッドをオーバーライドしたり、メソッドなどを追加して機能を拡張する。<br>
  一方、Decoratorパターンでは、機能ごとにクラスをあらかじめ用意しておく。<br>
  そして、クラスの組み合わせを変えることで、必要な機能を提供することができる。<br>

2. 注意点・問題点<br>
  - クラスが沢山できる<br>
    Decoratorパターンでは、機能ごとにクラスを用意するため、クラスの数が増える。<br>
    また、後から開発メンバーが入ってきた場合、Decoratorパターンが適用されていると知らないと利用の仕方がわからない、ということになりかねない。<br>
    それを避けるためにも、以下を行うと良い。<br>

    - クラス図を用意する（Decoratorパターン利用の旨を記載しておく）<br>
    - Javadocに機能を記載しておく<br>
    
    どちらもプロジェクトとしては当たり前のことだが、忙しいプロジェクトだと疎かになってしまいがちである。<br>
    きちんと設計書に残しておくことで、後からメンバーが入ったりする度に説明する手間も省ける。<br>


3. サンプルコードの解説<br>

- IceCream<br>
  中身と装飾を同じ章に扱うためのクラス。<br>
  中身と装飾は全て価格と名前を持っている（getPriceメソッドとgetNameメソッド）。<br>

- Corn<br>
  中身を表すクラスだが、アイスクリームのコーン部分を表している。<br>

- Ice<br>
  装飾を表すクラスで、コーンの上に載せるアイスを表している。<br>
  このクラスで中身と装飾を同じように扱うためのIceCreamクラスのインスタンスを持っている。<br>
  こうすることで、再起的な処理を行えるうようにしている。<br>

- Vamilla<br>
  バニラアイスを表している。<br>

- Chocolate<br>
  チョコレートアイスを表している。<br>

Decoratorパターンでは、以下クラスを作成する。<br>

- Component<br>
  中身と装飾うを一緒に扱うためのクラス。<br>
  このクラスで、各メソッドを定義しておく。<br>

- ConcreteComponent<br>
  中身を表すクラス。<br>

- Decorator<br>
  装飾を表すクラス。<br>
  このクラスなしに、Componentのインスタンスを持つように定義する。<br>
  そうすることで、ConcreteDecoratorクラスからComponentのメソッドを呼び出すことができるようになる。<br>

- ConcreteDecorator<br>
  具体的な装飾を表すクラス。<br>


4. 他のパターンとの関連<br>

- Adapterパターン<be>
  Detectorパターンでは、インダーフェースを変えずに機能を追加する。<br>
  Adapterパターンでは、違うインターフェースを提供する。<br>

- Compsiteパターン<br>
  Detectorパターンでは、機能を動的に追加することが目的。<br>
  Compositeパターンでは、木構造などの部分と全体からなる構造を扱うことが目的である。<br>

- Strategyパターン<br>
  Decoratorパターンでは、オブジェクトの中身を変えずに、装飾を追加していく。<br>
  Strategyパターンでは、中身のオブジェクトを変える。<br>


5. まとめ<br>

- Detectorパターンでは、中身と装飾を同一視することで再起的な処理を行うことができる。<br>

- 継承で機能を追加するのではなく、クラスの組み合わせで提供する機能を変えることができる。<br>

